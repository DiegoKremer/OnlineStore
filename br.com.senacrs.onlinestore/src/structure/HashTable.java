package structure;

import model.Book;

public class HashTable {

	/* Creates a cell that will store the key and value */

	public class HashCell {

		private String key;
		private Book value;

		public HashCell(String key, Book value) {
			this.key = key;
			this.value = value;
		}

		public String getKey() {
			return key;
		}

		public Book getValue() {
			return value;
		}

		public String toString() {

			return value.toString();

		}

	}

	private HashCell[] table;
	private int cycleControl = 0;
	private int initialCapacity = 13;

	/* Main constructor for the Hash Table */

	public HashTable() {
		table = new HashCell[this.initialCapacity];

	}

	/* Insertion method using Cuckoo collision handling */

	public void insert(Book value) {

		/*
		 * Run the first, second and third functions on the ISBN code from the
		 * book parameter and store on their respective variables
		 */
		int firstHash = hashFunctionOne(value.getISBN());
		// System.out.println("first hash: "+firstHash);
		int secondHash = hashFunctionTwo(value.getISBN());
		//System.out.println("second hash: " + secondHash);
		

		// System.out.println(table[firstHash]);
		// System.out.println(table[secondHash]);
		
		/* If position generated by first function is null will then add to it. */
		
		System.out.println("Testou o primeiro If do Insert");
		if (table[firstHash] == null) {
			table[firstHash] = new HashCell(value.getISBN(), value);
			cycleControl = 0;
			checkLoadFactor();

			/* If position not null will try the second function. */
			System.out.println("Testou o segundo If do Insert");
		} else if (table[secondHash] == null) {
			cycleControl = 0;
			checkLoadFactor();

			/*
			 * If position from second function also not null will move the
			 * element from the position and arrange a new position for the old
			 * one.
			 */

		} else {
			cycleControl++;
			if (cycleControl > 10) {
				System.out.println("Entrou cycleControl");
				reHash(table);
			} else {
				Book tempValue = table[secondHash].getValue();
				table[secondHash] = new HashCell(value.getISBN(), value);
				insert(tempValue);
				
			}
		}

	}

	/* Get the Book based on the provided key */

	public Book get(String isbn) {

		/*
		 * Run the first and second functions on the key received as parameter
		 * and store in their respective variables
		 */

		int firstHash = hashFunctionOne(isbn);
		int secondHash = hashFunctionTwo(isbn);

		/*
		 * Check if the table position of the result of the first function is
		 * not null and the key equals to the one from the slot and return the
		 * value stored there.
		 */
		try {

		if (table[firstHash] != null && table[firstHash].getKey().equals(isbn)) {
			return table[firstHash].getValue();

			/*
			 * If not the same key then it will jump to the position of the
			 * second function and return its value.
			 */

		} else if (table[secondHash] != null && table[secondHash].getKey().equals(isbn)) {
			return table[secondHash].getValue();
		}
		} catch (NullPointerException e) {
			System.out.println("Not found");
		}
		return null;
	}



	/* Returns the result of the first function to be used on the Hash Table */

	private int hashFunctionOne(String isbn) {
		char ch[];
		ch = isbn.toCharArray();
		int i, sum;
		for (sum = 0, i = 0; i < isbn.length(); i++) {
			sum += ch[i];
		}
		return sum % getCurrentCapacity();
	}

	/* Returns the result of the second function to be used on the Hash Table */

	private int hashFunctionTwo(String isbn) {
		char ch[];
		ch = isbn.toCharArray();
		int i, sum;
		for (sum = 0, i = 0; i < isbn.length(); i++) {
			sum += ch[i];
		}
		return sum % (getCurrentCapacity() / 3);
	}

	/*
	 * Method will check current usage percentage of the Hash Table and if it
	 * exceeds 85% will then double its size
	 */

	private void checkLoadFactor() {
		System.out.println("Rodou checkLoadFactor");
		double usedCapacity = getUsedCapacity();
		double currentCapacity = getCurrentCapacity();
		double usagePercentage = usedCapacity / currentCapacity;
		
		System.out.println("Resultado da divisao: "+usagePercentage);
		double usage = (usagePercentage) * 100;
		System.out.println("Resultado da porcentagem de utilização: "+usage);
		if (usage >= 50) {
			System.out.println("Detectou que utilização é maior que 60%");
			reHash(this.table);
		}
	}

	/*
	 * Increase the size of the hash table when it reaches its stipulated
	 * threshold
	 */

	private void reHash(HashCell[] tableParam) {
		System.out.println("Executou reHash");
		HashCell[] oldTable = new HashCell[getCurrentCapacity()];
		HashCell[] newTable = new HashCell[getCurrentCapacity() * 2];

		System.arraycopy(tableParam, 0, oldTable, 0, getCurrentCapacity());
		setTable(newTable);
		for (int i = 0; oldTable.length > i; i++) {
			if (oldTable[i] != null) {
				insert(oldTable[i].getValue());
			}
		}

	}

	/* Returns the total used capacity of the Hash Table */

	public int getUsedCapacity() {
		System.out.println("Verificou espaço utilizado");
		int used = 0;
		for (int i = 0; i < table.length; i++) {
			if (table[i] != null)
				used++;
		}
		System.out.println("Verificou espaço utilizado em: "+used);
		return used;
	}

	/* Returns the total capacity of the Hash Table */

	public int getCurrentCapacity() {
		System.out.println("Verificou tamanho atual em "+table.length);
		return table.length;
	}

	/* Sets a new table as the default Hash Table */

	private void setTable(HashCell[] table) {
		this.table = table;
	}

	public String toString() {

		/*
		 * Loop through the list appending the content while current position is
		 * not empty.
		 */

		String s = "Table Content: \n";

		for (int i = 0; i < table.length; i++) {
			if (table[i] == null) {
				s = s + "";
			} else
				s = s + table[i].getValue().toString() + "\n";
		}

		return s;

		/* Return the content of all list positions converted to String type */

	}

}
